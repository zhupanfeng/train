<script>
    // console.log(this) //window
    // function f(){
    //     console.log(this)//window
    // }
    // f()
    // let obj={
    //     name:"wangcai",
    //     say:function(){
    //         console.log(this)//obj
    //     }
    // }
    // // 谁调用了包含this的方法，this就指向谁
    // // obj调用了，this就指向obj
    // obj.say();

    // let fn=obj.say;
    // // fn是window调用，this 就指向window
    // fn();//window

        // this不能自己定义
    // this="hello"//Invalid left-hand side in assignment
</script>
<script>
    // 如果this出现在普通函数(不在对象里面)，那么this就是window
    // 如果this出现在一个对象的方法中，this可能指向这个对象，也可以指向window
    // 如果在调用函数之前加一个new的话，会创建并返回一个新的对象，而这个函数内部的this就会指向这个对象
    // 可以通过Function 对象的apply和call方法来指定函数内部的this的值
</script>
<script>
    // function f(){
    //     console.log(this)
    // }
    // // res就是一个新的对象
    // let res=new f();
</script>
<script>
//     function f(){
//         console.log(this)
//     }
//     // f当成一个普通函数调用
//     f();//window

//     // 把f当做一个构造器进行new new-->对象
//     new f();//f {}
//     // 如果你想要new一个函数,那么这个函数就叫做构造器，要是想把一个函数当做是构造器，最后把开头的字母大写

//     function Person(){
// //  Person本质是函数，当做构造器
//     }
//     let lisi=new Person();
</script>
<script>
//     function Person(name,age){
//         this.name=name;
//         this.age=age;
//     }
// // a是一个对象，Person内部的this就是a
//     let a=new Person("lisi",30)
//     console.log(a.name)

//     let b=new Person("w5",20)
//     console.log(b.name)
</script>
<script>
    // function f(){
    //     console.log(this)
    // }
    // let obj={
    //     name:"wa"
    // }
    // // f是对象，有两个方法，一个是call 一个是apply
    // // 让一个对象去借用一个方法
    // // 让obj去借用f方法,借用完,调用了
    // f.call(obj)//{name: "wa"}
    // f()
</script>
<script>
    // function f(a,b){
    //     console.log(a,b)
    // }
    // let obj={name:"ss"}
    // f.call(obj,1,2)
</script>
<script>
    // function f(a,b){
    //     console.log(a,b)
    // }
    // let obj={name:"ss"}
    // f.apply(obj,1,2)//出错
    // f.apply(obj,[1,2])
</script>

<script>
    // 判断数据类型 typeof instanceof 不太准确
    // toString Object.prototype.toString()
    // let a=[1,2,3]//Array
    // let b={name:"ss"}//Object
    // let c=function (){}//Function

    // console.log(Object.prototype.toString.call(a))//[object Array]
    // console.log(Object.prototype.toString.call(b))//[object Object]
    // console.log(Object.prototype.toString.call(c))//[object Function]
</script>
<script>
    // 两个对象，公用方法，输出name
    // let obj1={
    //     name:"z3",
    //     age:20,
    //     say:function (){
    //         console.log(`我是${this.name},年龄${this.age}`)
    //     }
    // }
    // let obj2={
    //     name:"l4",
    //     age:29,
    //     say:function (){
    //         console.log(`我是${this.name},年龄${this.age}`)
    //     }
    // }
    // obj1.say()
    // obj2.say()
</script>
<script>
    // 两个对象，公用方法，输出name
    // var f=function(){
    //     console.log(`我是${this.name},年龄${this.age}`)
    // }
    // let obj1={
    //     name:"z3",
    //     age:20,}
    //  let obj2={
    //     name:"z3",
    //     age:20,} 
    //     f.call(obj1)  
    //     f.call(obj2)  
</script>
<script>
    // 定义一个函数，功能是计算一个函数所用的时间
    // function computeTime(f){
    //     let startTime=new Date().getTime();
    //     let p=[];
    //     for(let i=1;i<arguments.length;i++){
    //         p.push(arguments[i])
    //     }
    //     f.apply(null,p)
    //     let endTime=new Date().getTime();
    //     let yourTime=endTime-startTime;
    //     return yourTime;
    // }
    // function f1(){}
    // function f2(a){}
    // function f3(a,b){}
    // function f4(a,b,c){}
    // console.log(computeTime(f2,10))
    // console.log(computeTime(f3,10,20))
    // console.log(computeTime(f4,10,20,30))
</script>
<script>
    // 去重

    let arr=[1,1,2,2,3,3]
    let newarr=[];
    let m={};

    for(let i=0;i<arr.length;i++)
    {
       var t=arr[i];
        if(m[t]){

        }else{
                newarr.push(arr[i])
                m[t]=true;
        }
    }
    console.log(newarr);

</script> 