<!-- 原型继承 -->
<script>
//     function Parent(yourname){
//         this.name=yourname;
//     }
//     Parent.prototype.say=function(){
//         console.log(this.name)
//     }
//     function Son(yourname){
//         this.name=yourname
//     }
//     // 让Son去继承Parent上的say的方法 继承
//     Son.prototype=Parent.prototype
//     // 修改constructor的指向
//     Son.prototype.constructor=Son;

//     let p=new Parent("hello")//hello
//     p.say();

//     let s=new Son("world")//world
//     s.say()
// // 会覆盖构造器中prototype中的constructor，导致对象的指向不明
// // 属性没有继承
</script>
<script>
    // function Parent(yourname){
    //     this.name=yourname;
    // }
    // Parent.prototype.say=function(){
    //     console.log(this.name)
    // }
    // // 让儿子去继承name属性和say方法
    // function Son(yourname){
    //     // 继承属性
    //     Parent.call(this,yourname)
    // }
    // Son.prototype=Parent.prototype;
    // Son.prototype.constructor=son;
</script>
<script>
    function Parent(yourname){
        this.name=yourname;
    }
    Parent.prototype.say=function(){
        console.log(this.name)
    }
    // 让儿子去继承name属性和say方法
    function Son(yourname){
        // 继承属性
        Parent.call(this,yourname)
    }
    Son.prototype=Parent.prototype;
    Son.prototype.constructor=son;



    // 还可以把原型对象copy一份，让Son继承copy过来的
    // Parent.prototype 循环一个对象 使用for in
    for(let i in Parent.prototype){
        Son.prototype[i]=Parent.prototype;
    }
    Son.prototype.constructor=Son;
</script>